"""
COMPASS Execution Plan Models

Defines the structure for orchestrator-generated execution plans.
"""

from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field
from enum import Enum
from datetime import datetime


class ToolName(str, Enum):
    """Available tools in the COMPASS system."""
    UNIMODAL_COMPRESSOR = "UnimodalCompressor"
    MULTIMODAL_NARRATIVE = "MultimodalNarrativeCreator"
    HYPOTHESIS_GENERATOR = "HypothesisGenerator"
    CODE_EXECUTOR = "CodeExecutor"
    FEATURE_SYNTHESIZER = "FeatureSynthesizer"
    CLINICAL_RANKER = "ClinicalRelevanceRanker"
    ANOMALY_NARRATIVE = "AnomalyNarrativeBuilder"
    PHENOTYPE_REPRESENTATION = "PhenotypeRepresentation"
    DIFFERENTIAL_DIAGNOSIS = "DifferentialDiagnosis"


class StepStatus(str, Enum):
    """Execution status for plan steps."""
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"
    RETRYING = "RETRYING"


class PlanStep(BaseModel):
    """
    A single step in the execution plan.
    
    Each step represents one tool call with its parameters and dependencies.
    """
    step_id: int = Field(..., description="Unique step identifier within the plan")
    tool_name: ToolName
    description: str = Field(..., description="Human-readable description of what this step does")
    reasoning: str = Field(default="", description="One sentence explanation for WHY this tool is used")
    input_domains: List[str] = Field(default_factory=list, description="Domains this step processes")
    parameters: Dict[str, Any] = Field(default_factory=dict, description="Tool-specific parameters")
    expected_output: str = Field(..., description="Description of expected output")
    estimated_tokens: int = Field(0, ge=0, description="Estimated token usage")
    depends_on: List[int] = Field(default_factory=list, description="Step IDs this step depends on")
    
    # Runtime fields (populated during execution)
    status: StepStatus = StepStatus.PENDING
    output: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    actual_tokens: Optional[int] = None
    execution_time_ms: Optional[int] = None
    retry_count: int = 0
    
    def can_execute(self, completed_steps: set) -> bool:
        """Check if all dependencies are satisfied."""
        return all(dep in completed_steps for dep in self.depends_on)
    
    def mark_completed(self, output: Dict[str, Any], tokens: int, time_ms: int):
        """Mark step as successfully completed."""
        self.status = StepStatus.COMPLETED
        self.output = output
        self.actual_tokens = tokens
        self.execution_time_ms = time_ms
    
    def mark_failed(self, error: str):
        """Mark step as failed."""
        self.status = StepStatus.FAILED
        self.error = error


class ExecutionPlan(BaseModel):
    """
    Complete execution plan generated by the Orchestrator.
    
    Contains ordered steps for processing participant data through the tool pipeline.
    """
    plan_id: str = Field(..., description="Unique plan identifier")
    participant_id: str
    target_condition: str = Field(..., description="neuropsychiatric or neurologic")
    created_at: datetime = Field(default_factory=datetime.now)
    
    # Planning metadata
    total_estimated_tokens: int = Field(0, ge=0)
    priority_domains: List[str] = Field(default_factory=list)
    fusion_strategy: str = Field("", description="How to combine all outputs")
    user_facing_explanation: str = Field("", description="Concise 2-sentence summary of the plan for the UI")
    reasoning: str = Field("", description="Orchestrator's reasoning for the plan")
    
    # Plan steps
    steps: List[PlanStep] = Field(default_factory=list)
    
    # Runtime tracking
    iteration: int = Field(1, description="Which iteration of the orchestration loop")
    previous_feedback: Optional[str] = Field(None, description="Feedback from critic if re-running")
    
    @property
    def total_steps(self) -> int:
        """Total number of steps in the plan."""
        return len(self.steps)
    
    @property
    def completed_steps(self) -> int:
        """Number of completed steps."""
        return sum(1 for s in self.steps if s.status == StepStatus.COMPLETED)
    
    @property
    def pending_steps(self) -> List[PlanStep]:
        """Get all pending steps."""
        return [s for s in self.steps if s.status == StepStatus.PENDING]
    
    @property
    def is_complete(self) -> bool:
        """Check if all steps are done (completed, failed, or skipped)."""
        terminal_states = {StepStatus.COMPLETED, StepStatus.FAILED, StepStatus.SKIPPED}
        return all(s.status in terminal_states for s in self.steps)
    
    @property
    def has_failures(self) -> bool:
        """Check if any steps failed."""
        return any(s.status == StepStatus.FAILED for s in self.steps)
    
    def get_step(self, step_id: int) -> Optional[PlanStep]:
        """Get a step by its ID."""
        for step in self.steps:
            if step.step_id == step_id:
                return step
        return None
    
    def get_next_executable_steps(self) -> List[PlanStep]:
        """Get steps that can be executed (dependencies satisfied)."""
        completed_ids = {s.step_id for s in self.steps if s.status == StepStatus.COMPLETED}
        return [
            s for s in self.steps 
            if s.status == StepStatus.PENDING and s.can_execute(completed_ids)
        ]
    
    def get_outputs_by_tool(self, tool_name: ToolName) -> List[Dict[str, Any]]:
        """Get all outputs from a specific tool."""
        return [
            s.output for s in self.steps 
            if s.tool_name == tool_name and s.output is not None
        ]
    
    def to_summary(self) -> Dict[str, Any]:
        """Generate a summary of the plan for logging."""
        return {
            "plan_id": self.plan_id,
            "participant_id": self.participant_id,
            "target": self.target_condition,
            "total_steps": self.total_steps,
            "completed": self.completed_steps,
            "priority_domains": self.priority_domains,
            "estimated_tokens": self.total_estimated_tokens,
            "iteration": self.iteration
        }


class PlanExecutionResult(BaseModel):
    """Result of executing a complete plan."""
    plan_id: str
    participant_id: str
    success: bool
    steps_completed: int
    steps_failed: int
    total_tokens_used: int
    total_execution_time_ms: int
    step_outputs: Dict[int, Dict[str, Any]] = Field(
        default_factory=dict,
        description="Map of step_id to output"
    )
    errors: List[Dict[str, Any]] = Field(default_factory=list)
    
    @classmethod
    def from_plan(cls, plan: ExecutionPlan) -> "PlanExecutionResult":
        """Create result from completed plan."""
        return cls(
            plan_id=plan.plan_id,
            participant_id=plan.participant_id,
            success=not plan.has_failures,
            steps_completed=plan.completed_steps,
            steps_failed=sum(1 for s in plan.steps if s.status == StepStatus.FAILED),
            total_tokens_used=sum(s.actual_tokens or 0 for s in plan.steps),
            total_execution_time_ms=sum(s.execution_time_ms or 0 for s in plan.steps),
            step_outputs={s.step_id: s.output for s in plan.steps if s.output},
            errors=[
                {"step_id": s.step_id, "tool": s.tool_name, "error": s.error}
                for s in plan.steps if s.error
            ]
        )
